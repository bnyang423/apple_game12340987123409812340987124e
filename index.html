<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Fruit Box (18x9)</title>
  <style>
    body { background: #fafafa; font-family: sans-serif; }
    #game { margin: 20px auto; display: block; }
    #scoreboard { font-size: 20px; margin: 10px 0; }
    #timer { font-size: 20px; margin: 10px 0; color: #d32f2f; }
    #btns { margin-bottom: 10px; }
    .btn { padding: 5px 14px; font-size: 15px; margin-right: 8px; border-radius: 5px; border: 1px solid #888; background: #fff; cursor: pointer; }
    #gameover-overlay {
      position: absolute;
      left: 0; top: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 10;
    }
    #gameover-content {
      background: #fff;
      padding: 40px 30px 30px 30px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 2px 16px rgba(0,0,0,0.2);
    }
    #game-container { position: relative; width: 900px; margin: 0 auto; }
    .score-label { font-size: 28px; font-weight: bold; margin-bottom: 10px; }
    .highscore-label { font-size: 20px; color: #666; }
    .reason-label { font-size: 22px; margin-bottom: 8px; color: #1976d2; }
    #restart-btn-center { margin-top: 22px; font-size: 18px; padding: 8px 34px; border-radius: 8px; }
  </style>
</head>
<body>
  <div id="timer">남은 시간: <span id="time">200</span>초</div>
  <div id="scoreboard">점수: <span id="score">0</span> / 최고점수: <span id="highscore">0</span></div>
  <div id="btns">
    <button class="btn" onclick="initGame()">다시 시작</button>
  </div>
  <div id="game-container">
    <canvas id="game" width="900" height="450"></canvas>
    <div id="gameover-overlay" style="display:none;">
      <div id="gameover-content">
        <div class="reason-label" id="end-reason"></div>
        <div class="score-label" id="final-score"></div>
        <div class="highscore-label" id="final-highscore"></div>
        <button class="btn" id="restart-btn-center" onclick="initGame()">다시 시작</button>
      </div>
    </div>
  </div>
  <script>
    // 게임 설정
    const COLS = 18;
    const ROWS = 9;
    const CELL_SIZE = 50;
    const CANVAS_W = COLS * CELL_SIZE;
    const CANVAS_H = ROWS * CELL_SIZE;

    // 사과 색상 (통일)
    const APPLE_COLOR = "#f44336"; // 빨간색

    // 제한시간(초)
    const TIME_LIMIT = 200;

    let apples = [];
    let selected = null;
    let score = 0;
    let highscore = 0;
    let gameover = false;
    let timer = TIME_LIMIT;
    let intervalId = null;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    const overlay = document.getElementById('gameover-overlay');
    const finalScoreEl = document.getElementById('final-score');
    const finalHighscoreEl = document.getElementById('final-highscore');
    const highscoreSpan = document.getElementById('highscore');
    const timerSpan = document.getElementById('time');
    const endReasonEl = document.getElementById('end-reason');

    function randAppleNum() {
      return Math.floor(Math.random() * 9) + 1;
    }

    function saveHighscore(val) {
      try {
        localStorage.setItem('fruitbox_highscore', String(val));
      } catch(e) {}
    }

    function loadHighscore() {
      try {
        const v = localStorage.getItem('fruitbox_highscore');
        return v ? parseInt(v) : 0;
      } catch(e) { return 0; }
    }

    function updateScoreDisplay() {
      document.getElementById('score').textContent = score;
      highscoreSpan.textContent = highscore;
    }

    function updateTimerDisplay() {
      timerSpan.textContent = timer;
    }

    function showGameOver(reason) {
      overlay.style.display = "flex";
      endReasonEl.textContent = reason;
      finalScoreEl.textContent = `최종 점수: ${score}`;
      finalHighscoreEl.textContent = `최고 점수: ${highscore}`;
    }

    function hideGameOver() {
      overlay.style.display = "none";
      endReasonEl.textContent = "";
    }

    function stopTimer() {
      if(intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    }

    function startTimer() {
      stopTimer();
      intervalId = setInterval(() => {
        if(gameover) return;
        timer--;
        updateTimerDisplay();
        if(timer <= 0) {
          timer = 0;
          updateTimerDisplay();
          endGame("제한시간 종료!");
        }
      }, 1000);
    }

    function initGame() {
      apples = [];
      for(let y=0; y<ROWS; y++) {
        let row = [];
        for(let x=0; x<COLS; x++) {
          row.push({num: randAppleNum(), gone: false});
        }
        apples.push(row);
      }
      score = 0;
      gameover = false;
      selected = null;
      timer = TIME_LIMIT;
      highscore = loadHighscore();
      updateScoreDisplay();
      updateTimerDisplay();
      hideGameOver();
      draw();
      startTimer();
    }

    function draw() {
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

      // grid
      ctx.strokeStyle = "#bbb";
      for(let x=0;x<=COLS;x++) {
        ctx.beginPath();
        ctx.moveTo(x*CELL_SIZE,0);
        ctx.lineTo(x*CELL_SIZE,CANVAS_H);
        ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++) {
        ctx.beginPath();
        ctx.moveTo(0,y*CELL_SIZE);
        ctx.lineTo(CANVAS_W,y*CELL_SIZE);
        ctx.stroke();
      }

      // apples
      for(let y=0;y<ROWS;y++) {
        for(let x=0;x<COLS;x++) {
          let a = apples[y][x];
          if(a.gone) continue;
          let cx = x*CELL_SIZE + CELL_SIZE/2;
          let cy = y*CELL_SIZE + CELL_SIZE/2;
          ctx.beginPath();
          ctx.arc(cx,cy,CELL_SIZE/2-8,0,2*Math.PI);
          ctx.fillStyle = APPLE_COLOR;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#7b3e00";
          ctx.stroke();
          ctx.lineWidth = 1;
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(a.num,cx,cy);
        }
      }
      // 선택 영역 드래그 표시
      if(selected) {
        let {x1,y1,x2,y2,valid} = selected;
        let sx = Math.min(x1,x2)*CELL_SIZE;
        let sy = Math.min(y1,y2)*CELL_SIZE;
        let ex = (Math.max(x1,x2)+1)*CELL_SIZE;
        let ey = (Math.max(y1,y2)+1)*CELL_SIZE;
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = valid ? "#f44336" : "#06f";
        ctx.fillRect(sx,sy,ex-sx,ey-sy);
        ctx.restore();
        ctx.lineWidth = 3;
        ctx.strokeStyle = valid ? "#f44336" : "#06f";
        ctx.strokeRect(sx,sy,ex-sx,ey-sy);
      }
    }

    function getApplesInRect(x1,y1,x2,y2) {
      let minX = Math.min(x1,x2);
      let maxX = Math.max(x1,x2);
      let minY = Math.min(y1,y2);
      let maxY = Math.max(y1,y2);
      let arr = [];
      for(let y=minY;y<=maxY;y++) {
        for(let x=minX;x<=maxX;x++) {
          if(apples[y][x] && !apples[y][x].gone) arr.push({x,y,num: apples[y][x].num});
        }
      }
      return arr;
    }

    function checkSum10(applesArr) {
      let sum = applesArr.reduce((acc,a)=>acc+a.num,0);
      return sum===10;
    }

    // 모든 사과가 지워졌는지 확인
    function allApplesGone() {
      for(let y=0;y<ROWS;y++) {
        for(let x=0;x<COLS;x++) {
          if(apples[y][x] && !apples[y][x].gone) return false;
        }
      }
      return true;
    }

    // 더 이상 조합이 가능한지 체크 (합이 10이 되는 직사각형이 있는지)
    function hasAvailableMove() {
      for(let y1=0; y1<ROWS; y1++) {
        for(let x1=0; x1<COLS; x1++) {
          for(let y2=y1; y2<ROWS; y2++) {
            for(let x2=x1; x2<COLS; x2++) {
              let applesArr = getApplesInRect(x1, y1, x2, y2);
              if(applesArr.length>0 && checkSum10(applesArr)) return true;
            }
          }
        }
      }
      return false;
    }

    // 게임 종료 처리
    function endGame(reason) {
      gameover = true;
      stopTimer();
      if(score > highscore) {
        highscore = score;
        saveHighscore(highscore);
      }
      updateScoreDisplay();
      showGameOver(reason);
    }

    // 마우스/터치 이벤트
    let dragging = false;
    let startCell = null;

    function eventToCell(e) {
      let rect = canvas.getBoundingClientRect();
      let x = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left);
      let y = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top);
      let cx = Math.floor(x/CELL_SIZE);
      let cy = Math.floor(y/CELL_SIZE);
      return {x: Math.max(0,Math.min(COLS-1,cx)), y: Math.max(0,Math.min(ROWS-1,cy))};
    }

    function checkGameEnd() {
      if(allApplesGone()) {
        endGame("모든 사과를 지웠습니다!");
      } else if(!hasAvailableMove()) {
        endGame("더 이상 지울 수 있는 사과가 없습니다!");
      }
    }

    canvas.addEventListener('mousedown', e => {
      if(gameover) return;
      dragging = true;
      startCell = eventToCell(e);
      selected = {...startCell, x2: startCell.x, y2: startCell.y, valid:false};
      draw();
    });
    canvas.addEventListener('mousemove', e => {
      if(!dragging || gameover) return;
      let curr = eventToCell(e);
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      selected = {x1: startCell.x, y1: startCell.y, x2: curr.x, y2: curr.y, valid};
      draw();
    });
    canvas.addEventListener('mouseup', e => {
      if(!dragging || gameover) return;
      let curr = eventToCell(e);
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      if(valid) {
        applesArr.forEach(a=>{apples[a.y][a.x].gone=true;});
        score += applesArr.length;
        updateScoreDisplay();
        draw();
        setTimeout(checkGameEnd, 100);
      }
      selected = null;
      dragging = false;
      draw();
    });

    // 모바일 터치 대응
    canvas.addEventListener('touchstart', e => {
      if(gameover) return;
      e.preventDefault();
      dragging = true;
      startCell = eventToCell(e);
      selected = {...startCell, x2: startCell.x, y2: startCell.y, valid:false};
      draw();
    },{passive:false});
    canvas.addEventListener('touchmove', e => {
      if(!dragging || gameover) return;
      let curr = eventToCell(e);
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      selected = {x1: startCell.x, y1: startCell.y, x2: curr.x, y2: curr.y, valid};
      draw();
    },{passive:false});
    canvas.addEventListener('touchend', e => {
      if(!dragging || gameover) return;
      let curr = selected ? {x:selected.x2, y:selected.y2} : startCell;
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      if(valid) {
        applesArr.forEach(a=>{apples[a.y][a.x].gone=true;});
        score += applesArr.length;
        updateScoreDisplay();
        draw();
        setTimeout(checkGameEnd, 100);
      }
      selected = null;
      dragging = false;
      draw();
    },{passive:false});

    // 첫 시작
    window.onload = () => {
      highscore = loadHighscore();
      initGame();
    };
  </script>
</body>
</html>
